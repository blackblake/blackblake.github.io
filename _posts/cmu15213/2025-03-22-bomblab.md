---
title: "bomblab"
date: 2025-03-22 03:39:16 +0800
categories: [cmu15213, lab]
tags: [csapp]     # TAG names should always be lowercase
---
[小土刀's Blog](https://wdxtub.com/csapp/thick-csapp-lab-2/2016/04/16/)

>复习的时候一定先读上面这篇Blog，关于gdb指令的内容很详尽

具体的过程在这篇Blog里非常详尽，且大一下学期在学校的计算机系统基础课上已经做过BombLab，本篇只记录一些需要注意的细节  

Phase_1
---
---

```c
0000000000400ee0 <phase_1>:
400ee0: 48 83 ec 08                  	subq	$0x8, %rsp

400ee4: be 00 24 40 00               	movl	$0x402400, %esi         # imm = 0x402400
400ee9: e8 4a 04 00 00               	callq	0x401338 <strings_not_equal>
400eee: 85 c0                        	testl	%eax, %eax
400ef0: 74 05                        	je	0x400ef7 <phase_1+0x17>
400ef2: e8 43 05 00 00               	callq	0x40143a <explode_bomb>
400ef7: 48 83 c4 08                  	addq	$0x8, %rsp

400efb: c3                           	retq
```

### 1. 寄存器的意义
一年前上csapp的时候，最头疼的就是x86中各种各样的寄存器，记不清它们的意义，这里只列出一些lab中用到的寄存器的意义：

#### 1）R与E
- R开头的寄存器如RAX（64位），包含了E开头的寄存器如EAX（低32位），而EAX又包含了AX（低16位）
- 比如对RDX寄存器，可以通过以下方式访问其部分位：
  - RDX：完整64位
  - EDX：低32位
  - DX：低16位
  - DL：低8位
#### 2）常见寄存器
* %rbp: 基址指针寄存器，通常用于标记函数栈帧的底部
* %rbx: 基址寄存器，在这段代码中作为数组指针使用
* %rsp: 栈指针寄存器，指向栈顶
* %rsi: 第二参数寄存器，用于传递函数参数
* %eax: 累加器寄存器的低32位，用于计算和比较

### 2.Phase_1
1）%esi作为函数调用的第2个参数寄存器，存储了0x402400这个值，一看就是个地址，所以要用x/s指令查看这个地址所存放的内容是什么（就是phase1的答案）

2）而`string_not_equal`函数的第一个参数，自然就是我们输入的字符串，通过`testl %eax, %eax`和`je`这两个指令来判断我们输入的字符串是否等于0x402400这个地址里存放的字符串

Phase_2
---
---

第二关比较复杂: 
```c
0x0000000000400efc <+0>:     push   %rbp      ; 保存基址指针寄存器rbp的值到栈上
0x0000000000400efd <+1>:     push   %rbx      ; 保存基址寄存器rbx的值到栈上
0x0000000000400efe <+2>:     sub    $0x28,%rsp ; 在栈上分配40字节(0x28)的空间
0x0000000000400f02 <+6>:     mov    %rsp,%rsi  ; 将栈顶指针复制给第二参数寄存器rsi
0x0000000000400f05 <+9>:     call   0x40145c <read_six_numbers> ; 调用函数读取6个数字到栈上
0x0000000000400f0a <+14>:    cmpl   $0x1,(%rsp) ; 比较栈顶位置的值是否等于1
0x0000000000400f0e <+18>:    je     0x400f30 <phase_2+52> ; 如果等于1，跳转到+52处


0x0000000000400f10 <+20>:    call   0x40143a <explode_bomb> ; 否则，调用炸弹函数(游戏失败)
0x0000000000400f15 <+25>:    jmp    0x400f30 <phase_2+52> ; 跳转到+52处(实际上这行代码不会执行)


0x0000000000400f17 <+27>:    mov    -0x4(%rbx),%eax ; 将rbx指针前4字节的值(前一个数字)存入eax
0x0000000000400f1a <+30>:    add    %eax,%eax       ; 将eax的值翻倍
0x0000000000400f1c <+32>:    cmp    %eax,(%rbx)     ; 比较当前rbx指向的值是否等于eax(翻倍的前一个数)
0x0000000000400f1e <+34>:    je     0x400f25 <phase_2+41> ; 如果相等，跳转到+41处
0x0000000000400f20 <+36>:    call   0x40143a <explode_bomb> ; 否则，调用炸弹函数(游戏失败)
0x0000000000400f25 <+41>:    add    $0x4,%rbx       ; rbx指针增加4字节(指向下一个数字)
0x0000000000400f29 <+45>:    cmp    %rbp,%rbx       ; 比较rbx是否等于rbp(是否达到数组末尾)
0x0000000000400f2c <+48>:    jne    0x400f17 <phase_2+27> ; 如果不等于，跳回+27处继续循环
0x0000000000400f2e <+50>:    jmp    0x400f3c <phase_2+64> ; 跳转到+64处(函数结尾)


0x0000000000400f30 <+52>:    lea    0x4(%rsp),%rbx  ; 将第二个数字的地址加载到rbx
0x0000000000400f35 <+57>:    lea    0x18(%rsp),%rbp ; 将数组结束后的地址加载到rbp(栈顶+24字节)
0x0000000000400f3a <+62>:    jmp    0x400f17 <phase_2+27> ; 跳转到+27处开始循环
0x0000000000400f3c <+64>:    add    $0x28,%rsp      ; 恢复栈指针(释放之前分配的空间)
0x0000000000400f40 <+68>:    pop    %rbx            ; 恢复rbx的值
0x0000000000400f41 <+69>:    pop    %rbp            ; 恢复rbp的值
0x0000000000400f42 <+70>:    ret                    ; 返回，函数结束
```

这一关的逻辑是：

1. 读取6个数字到栈上
2. 检查第一个数字是否为1，不是则引爆炸弹
3. 检查后续每个数字是否是前一个数字的2倍，不是则引爆炸弹

### 寄存器
还是先解释一下这个函数调用过程的各个寄存器：
#### 1. `%rsp`: 在这一关里保存了我们输入的整数数组的起始地址，这一点可以由以下地方看出
   - 在函数开始时，执行了 sub $0x28,%rsp 指令，在栈上分配了空间
   - 然后执行 mov %rsp,%rsi 指令，将栈指针（指向栈顶，也就是分配空间后的栈顶）复制给了 %rsi 寄存器
   - 接着调用 read_six_numbers 函数，并将 %rsi 作为参数传递，这个函数会将读取的6个数字存储到 %rsi 指向的地址，即 %rsp 指向的位置
   - 在后续的代码中，通过 cmpl $0x1,(%rsp) 指令直接比较栈顶位置的值，证明第一个元素确实存储在 %rsp 指向的位置
#### 2.
