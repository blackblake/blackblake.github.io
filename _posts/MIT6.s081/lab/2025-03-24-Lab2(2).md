---
title: "lab2 syscall (second time)"
date: 2025-03-24 03:39:16 +0800
categories: [MIT6.S081, os_Lab]
tags: [os]     # TAG names should always be lowercase
---

一、创建系统调用的方法论
---
---
[来自miigon's blog](https://blog.miigon.net/posts/s081-lab2-system-calls/#如何创建新系统调用)

### step1 实现系统调用sys_name
首先在内核中合适的位置（取决于要实现的功能属于什么模块），实现我们的内核调用（在这里是 trace 调用）

>在`sys_name`函数中实现名为name的系统调用

比如我们的系统调用A会对进程进行操作，所以把A的实现sys_A函数放在 sysproc.c 较为合适。

### step2 添加序号
在 syscall.h 中加入新 system call 的序号：
```c
// kernel/syscall.h
// System call numbers
...
#define SYS_mkdir  20
#define SYS_close  21
#define SYS_trace  22 // here!!!!!
```
### step3 `sys_name`  函数的全局extern声明
用 extern 全局声明新的内核调用函数，并且在 syscalls 映射表中，加入从前面定义的编号到系统调用函数指针的映射

```c
// kernel/syscall.c
...
extern uint64 sys_write(void);
extern uint64 sys_uptime(void);
extern uint64 sys_trace(void);   // HERE
```
### step4 向`syscalls`数组中添加元素
```c
static uint64 (*syscalls[])(void) = {
...
[SYS_mkdir]   sys_mkdir,
[SYS_close]   sys_close,
[SYS_trace]   sys_trace,  // AND HERE
};
```
这里 [SYS_trace] sys_trace 是 C 语言数组的一个语法，表示以方括号内的值作为元素下标。比如 `int arr[] = {[3] 2333, [6] 6666}` 代表 arr 的下标 3 的元素为 2333，下标 6 的元素为 6666，其他元素填充 0 的数组。

### step5 在`usys.pl`脚本中添加条目
```c
# user/usys.pl
...
entry("sleep");
entry("uptime");
entry("trace");  # HERE
```

这个perl脚本在运行后会生成 `usys.S` 汇编文件，里面定义了每个 system call 的 **用户态跳板函数** ：

```plaintext
trace:		# 定义用户态跳板函数
li a7, SYS_trace	# 将系统调用 id 存入 a7 寄存器
ecall				# ecall，调用 system call ，跳到内核态的统一系统调用处理函数 syscall()  (syscall.c)
ret
```

### step6 ` user.h`
在用户态的头文件加入定义，使得用户态程序可以找到这个跳板入口函数。
```c
// user/user.h
// system calls
...
int sleep(int);
int uptime(void);
int trace(int);		// HERE
```

二、系统调用的流程
---
---

>1. user/user.h:		用户态程序调用跳板函数 trace()
>2. user/usys.S:		跳板函数 trace() 使用 CPU 提供的 ecall 指令，调用到内核态
>3. kernel/syscall.c	到达内核态统一系统调用处理函数 syscall()，所有系统调用都会跳到这里来处理。
>4. kernel/syscall.c	syscall() 根据跳板传进来的系统调用编号，查询 syscalls[] 表，找到对应的内核函数并调用。
>5. kernel/sysproc.c	到达 sys_trace() 函数，执行具体内核操作


三、Trace syscall
---
---

### 1）锁的代码

```c
// Acquire the lock.
// Loops (spins) until the lock is acquired.
void
acquire(struct spinlock *lk)
{
  push_off(); // disable interrupts to avoid deadlock.
  if(holding(lk))
    panic("acquire");

  // On RISC-V, sync_lock_test_and_set turns into an atomic swap:
  //   a5 = 1
  //   s1 = &lk->locked
  //   amoswap.w.aq a5, a5, (s1)
  while(__sync_lock_test_and_set(&lk->locked, 1) != 0)
    ;

  // Tell the C compiler and the processor to not move loads or stores
  // past this point, to ensure that the critical section's memory
  // references happen strictly after the lock is acquired.
  // On RISC-V, this emits a fence instruction.
  __sync_synchronize();

  // Record info about lock acquisition for holding() and debugging.
  lk->cpu = mycpu();
}
```
这是一个自旋锁(spinlock)的获取函数实现：

1. `push_off()`  禁用中断以避免死锁。这是因为如果在持有锁的过程中发生中断，可能导致系统死锁。

2. `if(holding(lk)) panic("acquire")`  检查当前CPU是否已经持有该锁，如果是则触发panic，防止重复获取同一个锁而导致死锁。
   >"panic"是一个重要的错误处理机制，表示系统遇到了无法恢复的严重错误
3. `__sync_lock_test_and_set(&lk->locked, 1)` 
  - 这是一个原子操作，尝试将锁的状态设置为1(表示锁定)，同时返回锁之前的状态：
  - 注释中解释了在RISC-V架构上，这个操作会转换为原子交换指令`amoswap.w.aq`
  - 如果返回0，表示锁之前是未锁定状态，现在已经成功获取
  - 如果返回非0，表示锁已经被其他CPU持有，需要继续尝试(自旋)

>4. `while(...) ;` 这是自旋锁的核心：如果锁已被占用，函数会在这个循环中"自旋"(不断尝试)直到成功获取锁。

5. `__sync_synchronize()`  内存屏障，确保锁获取之后的所有内存操作严格在获取锁之后执行，防止编译器和处理器的指令重排。

6. `lk->cpu = mycpu()`  记录哪个CPU获取了锁，用于调试和`holding()`函数检查。

>函数 release（1502）则做了与 acquire 相反的事：清除调试信息并释放锁。

