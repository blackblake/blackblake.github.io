
1. `import torch` : 不是"pytorch"
	
2. `x = torch.arange(12)` : 生成一个shape为 `(12,)` 的向量，注意 **元组里有几个数字，张量就是几维的**，`(12,)`只有一个数字，所以是一维张量，没有行与列的概念，因而**12不是代表12行**，**真正的“12行”**，其形状应该是二维的，写作 `(12, 1)`；
	
3. `x.shape`
	
4. `x.numl()`
	
5. `X = x.reshape(3, 4)` : 
	- 这个元组`(3,4)`有两个数字，所以新张量就是3行4列的
	- 可以用x.reshape(-1,4)或x.reshape(3,-1)来取代
	
6. `torch.zeros((2, 3, 4))` :
	 - `.zeros()`把所有元素初始化为0
	 - `.ones()`把所有元素初始化为1

7. `torch.randn(3, 4)` : 张量的每个元素都从 **标准正态分布** 中随机采样得到
	
8. `torch.tensor([[2, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])` : 直接指定元素值

9. `torch.exp(x)` : 对输入张量 `x` 中的每一个元素，都计算 $e^x$ 的值 

10. **拼接**
	
```Python
X = torch.arange(12, dtype=torch.float32).reshape((3,4))

Y = torch.tensor([[2.0, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])
# 拼接
torch.cat((X, Y), dim=0) # 按行拼接
torch.cat((X, Y), dim=1) # 按列拼接
```
- `dim=0`：0代表shape的第0纬，也就是“行”
- `dim=1`：1代表shape的第1纬，也就是“列”
- 第一个输出张量的轴0长度（6）是两个输入张量轴0长度的总和（3 + 3）
- 第二个输出张量的轴‐1长度（8）是两个输入张量轴‐1长度的总和（4 + 4）
	
```plaintext
(tensor([[ 0., 1., 2., 3.],
[ 4., 5., 6., 7.],
[ 8., 9., 10., 11.],
[ 2., 1., 4., 3.],
[ 1., 2., 3., 4.],
[ 4., 3., 2., 1.]]),

tensor([[ 0., 1., 2., 3., 2., 1., 4., 3.],
[ 4., 5., 6., 7., 1., 2., 3., 4.],
[ 8., 9., 10., 11., 4., 3., 2., 1.]]))
```


11. `X.sum()`：对张量中的所有元素进行求和，会产生一个单元素张量