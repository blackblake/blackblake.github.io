---
title: "chap1 solutions"
date: 2025-03-21 03:39:16 +0800
categories: [algorithm design, Solutions]
tags: [solution]     # TAG names should always be lowercase
---

1.1
---
---
![binary-search](/assets/Image/binasear.png){: w="300", h"200" }

>Let A[1..60] = 11, 12,..., 70. How many comparisons are performed by
>Algorithm binarysearch when searching for the following values of x?
>(a) 33. (b) 7. (c) 70. (d) 77.

#### (a) 搜索值33：

1. 第一次比较：
  - 中间位置：(1 + 60) / 2 = 30.5，向下取整为30
  - 中间元素是A[30] = 40（因为A[1] = 11，每个元素递增1）
  - 33 < 40，所以在左半部分继续搜索，新区间为A[1..29]

2. 第二次比较：
  - 中间位置：(1 + 29) / 2 = 15
  - 中间元素是A[15] = 25
  - 33 > 25，所以在右半部分继续搜索，新区间为A[16..29]

3. 第三次比较：
  - 中间位置：(16 + 29) / 2 = 22.5，向下取整为22
  - 中间元素是A[22] = 32
  - 33 > 32，所以在右半部分继续搜索，新区间为A[23..29]

4. 第四次比较：
  - 中间位置：(23 + 29) / 2 = 26
  - 中间元素是A[26] = 36
  - 33 < 36，所以在左半部分继续搜索，新区间为A[23..25]

5. 第五次比较：
  - 中间位置：(23 + 25) / 2 = 24
  - 中间元素是A[24] = 34
  - 33 < 34，所以在左半部分继续搜索，新区间为A[23..23]

6. 第六次比较：
  - 只剩一个元素，直接比较
  - A[23] = 33
  - 找到目标值

总共需要6次比较。

> - mid的计算是向下取整的
> 
> - 若 x!=A[mid]，要么low=mid+1，要么high=mid-1，一定要记住不是等于mid！

#### (b) 搜索值7：
由于数组最小值是11，7不在数组中。

需要执行⌊log₂60⌋+1 = 6次比较确定元素不存在。


1.5 选择排序的比较次数（套路题）
---
---
>Illustrate the operation of Algorithm SELECTION_SORT on the array 
> \[45 33 24 45 12 12 24 12] . 
> How many comparisons are performed by the algorithm?

算法执行了7+6+5+4+3+2+1=28次比较

#### 1. 选择排序的比较操作固定为 n(n - 1)/2 次，即本体所求
#### 2. 注意要区分“比较次数”和“交换次数”，后者并不固定，可以介于 0 和 (n - 1)次之间
#### 3. 还可能求“赋值操作”的次数：选择排序的赋值操作介于 0 和 3(n - 1) 次之间

>ps: 一次交换对应三次赋值

1.6 MOD_SELECTION_SORT
---
---
算法 1.16 MODSELECTIONSORT

```perl
for i ← 1 to n - 1
for j ← i + 1 to n

Copy  if A[j] < A[i] then 交换 A[i] 和 A[j]

end for
end for
```
#### (a) 算法 MODSELECTIONSORT 执行的最小元素赋值次数是多少？这个最小值在什么情况下达到？
- 最小赋值数量的情况是当数组已经按照非递减顺序排序时。在这种情况下，因为对任何j，A[j] ≥ A[i]都成立，所以内层循环中的if条件永远不会为真，因此不会进行任何交换。
- 最小元素赋值数量：0次
#### (b) 算法 MODSELECTIONSORT 执行的最大元素赋值次数是多少？注意每次交换操作使用三次元素赋值来实现。这个最大值在什么情况下达到？
1. 最坏情况发生在数组按照严格递减顺序排序时（如n, n-1, n-2, ..., 2, 1）。在这种情况下：

  当i=1时，j将从2到n，每次比较A[j]都小于A[i]，所以将进行(n-1)次交换
  当i=2时，j将从3到n，进行(n-2)次交换
  当i=3时，j将从4到n，进行(n-3)次交换
  依此类推...
  总交换次数 = (n-1) + (n-2) + (n-3) + ... + 2 + 1 = n(n-1)/2

2. 由于 **每次交换需要3次元素赋值** ，所以：最大元素赋值数量 = 3 × n(n-1)/2 = 3n(n-1)/2

> 每次交换操作需要3次赋值操作

> 可以自己画个数组模拟一下

1.8 求插入排序的比较次数
---
---
[插入排序图示](https://www.bilibili.com/video/BV1tf421Q7eh?vd_source=3bdded820f6a4ab7fb95ff48d96608df)

初始数组: [4,3,12,5,6,7,2,9]

j=2: 比较3和4，交换 → [3,4,12,5,6,7,2,9]，1次比较
j=3: 比较12和4，不交换 → [3,4,12,5,6,7,2,9]，1次比较
j=4: 比较5和12，交换；与4比较，不交换 → [3,4,5,12,6,7,2,9]，2次比较
j=5: 比较6和12，交换；与5比较，不交换 → [3,4,5,6,12,7,2,9]，2次比较
j=6: 比较7和12，交换；与6比较，不交换 → [3,4,5,6,7,12,2,9]，2次比较
j=7: 比较2和12，交换；与7交换；与6交换；与5交换；与4交换；与3交换；与无比较，停止 → [2,3,4,5,6,7,12,9]，6次比较
j=8: 比较9和12，交换；与7比较，不交换 → [2,3,4,5,6,7,9,12]，2次比较

总比较次数：1+1+2+2+2+6+2 = 16次比较


1.10 插入排序vs.选择排序
---
---

#### 1）时间复杂度：

两者最坏情况下都是O(n²)
插入排序对部分排序的数组有优势，最好情况可达O(n)
选择排序始终是O(n²)，无论输入如何

#### 2）比较和移动次数：

插入排序：比较次数最坏为n(n-1)/2，移动次数最坏也为n(n-1)/2
选择排序：比较次数恒为n(n-1)/2，移动次数最多为3(n-1)

#### 3）大型记录的影响：

插入排序需要多次移动记录，每次迭代可能涉及多次数据移动
选择排序只在确定位置后移动一次记录


#### 4）结论
对于非常大的记录，选择排序通常更有效率，因为它最小化了记录移动次数。虽然两者比较次数相似，但插入排序的多次移动操作在大记录情况下成本高昂。
