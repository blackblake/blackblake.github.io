---
title: "Chap5 归纳法"
date: 2025-04-05 03:39:16 +0800
categories: [Algorithm Design, Solutions]
tags: [solution]     # TAG names should always be lowercase
---

4.2 
---
---
>用迭代算法计算斐波那契数
```plaintext
long long Fibonacci(int n)
{
	if (n == 0)
		return 0;
	else if (n == 1)
		return 1;
	long long a = 0;
	long long b = 1;
	long long c = 1;
	while (n - 2)
	{
		a = b;
		b = c;
		c = a + b;
		n--;
	}
	return c;
}
```

4.3 
---
---
> 用归纳法开发一个递归算法，找出序列A\[1..n] 中的最大元素

![description](/assets/Image/4.3.png)

4.4
---
---
> 用归纳法开发一个递归算法，计算序列A\[1..n] 中的平均值

![description](/assets/Image/4.4.png)

4.5
---
---
> 用归纳法开发一个递归算法，在序列A\[1..n] 中搜寻元素x

![description](/assets/Image/4.5.png)


4.6
---
---
> 计算SELECTIONSORT的运行时间

见书P91

1. 递归版本的选择排序比起P8的迭代版选择排序，只是把最外层的for循环改成了递归`sort(i+1)`而已
2.  $c(n-1)+(n-1)$ 代表n-1次元素比较次数加上对A\[2...n]排序的比较次数
![description](/assets/Image/4.6.png){: w="100", h"50" }


4.7
---
---
实现选择排序（SELECTIONSORT）、插入排序（INSERTIONSORT）和冒泡排序（BUBBLESORT）的递归版本
---

### 4.6 选择排序（递归版）

#### 代码
```cpp
// 递归实现选择排序
void selectionSort(vector<int>& A, int start, int n) {
    // 基础情况：如果 start 到达 n-1，只剩一个或没有元素，无需排序
    if (start >= n - 1) {
        return;
    }

    // 找到从 start 到末尾的最小元素索引
    int min_idx = start;
    for (int i = start + 1; i < n; i++) {
        if (A[i] < A[min_idx]) {
            min_idx = i;
        }
    }

    // 交换 start 位置和最小元素位置
    swap(A[start], A[min_idx]);

    // 递归处理从 start+1 到末尾的部分
    selectionSort(A, start + 1, n);
}
```

#### 说明
- `start` 表示当前未排序部分的起始位置，`n` 是数组长度。
- 每次递归找到最小元素，放到 `start` 位置，然后递归处理剩余部分。


### 4.7 插入排序（递归版）

#### 代码
```cpp
// 递归实现插入排序
void insertionSort(vector<int>& A, int n) {
    // 基础情况：如果 n <= 1，只有一个或没有元素，无需排序
    if (n <= 1) {
        return;
    }

    // 递归排序前 n-1 个元素
    insertionSort(A, n - 1);

    // 取最后一个元素，插入到前 n-1 个已排序部分的正确位置
    int key = A[n - 1];
    int j = n - 2;

    // 向后移动大于 key 的元素
    while (j >= 0 && A[j] > key) {
        A[j + 1] = A[j];
        j--;
    }

    // 插入 key 到正确位置
    A[j + 1] = key;
}
```

#### 说明
- 递归排序前 \( n-1 \) 个元素。
- 取最后一个元素 `key`，通过移动元素将其插入到已排序部分的正确位置。



4.8 冒泡排序\(递归版)
---
---
#### 代码
```cpp
// 递归实现冒泡排序
void bubbleSort(vector<int>& A, int n) {
    // 基础情况：如果 n <= 1，只有一个或没有元素，无需排序
    if (n <= 1) {
        return;
    }

    // 一轮冒泡，将最大元素放到末尾
    for (int i = 0; i < n - 1; i++) {
        if (A[i] > A[i + 1]) {
            swap(A[i], A[i + 1]);
        }
    }

    // 递归处理前 n-1 个元素
    bubbleSort(A, n - 1);
}
```

#### 说明
- 每轮冒泡将最大元素放到末尾。
- 递归处理前 \( n-1 \) 个元素，直到数组完全排序。

### 规律

可以看出，这三个排序算法的递归版和迭代版的区别就是：用递归调用自身的方式，代替了迭代法的外层for循环。
