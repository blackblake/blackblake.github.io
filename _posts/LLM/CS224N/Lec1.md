
## 局部表示 vs. 分布式表示
---

### 1. 局部表示 (Local Representation)

**核心思想**：用一个独立的、原子化的符号来表示一个概念。每个概念对应一个符号，符号之间没有任何关系。

**最典型的例子：独热编码 (One-Hot Encoding)**

假设我们的词汇表里只有四个词：\["king", "queen", "man", "woman"]。

用局部表示法，我们会这样表示它们：

- `king` -> `[1, 0, 0, 0]`
    
- `queen` -> `[0, 1, 0, 0]`
    
- `man` -> `[0, 0, 1, 0]`
    
- `woman` -> `[0, 0, 0, 1]`
    

**特点：**

- **原子性/独立性**：每个向量只有一个维度是“激活”的（值为1），其余都是0。`king`的向量和`queen`的向量是完全独立的。
    
- **无语义关系**：从这些向量本身，你无法得知`king`和`man`的关系比`king`和`woman`更近。所有向量之间的几何距离（例如欧氏距离）都是相等的。它们是正交的，相互之间没有任何相似度的信息。
    
- **高维稀疏**：如果词汇表有一万个词，那么每个词的向量就是一万维，并且其中9999个维度都是0，非常稀疏且占用空间。
    

**“局部”的含义**：一个概念的全部意义都**局限在**向量的**某一个特定位置**上。`king`的意义就在第一个位置，`queen`的意义就在第二个位置，泾渭分明。

---

### 2. 分布式表示 (Distributed Representation)

**核心思想**：用一个**稠密的向量**（大部分元素都非零）来表示一个概念。一个概念的意义**分布在**向量的**所有维度**上，同时每个维度也参与构成**多个概念**的意义。

**最典型的例子：词嵌入/词向量 (Word Embedding / Word Vector)**

继续用上面的例子，用分布式表示法，我们可能会得到这样的结果（这里的数字仅为示意）：

- `king` -> `[0.98, -0.89, 0.72, 0.15]`
    
- `queen` -> `[0.95, 0.85, 0.69, 0.12]`
    
- `man` -> `[0.68, -0.92, -0.45, 0.88]`
    
- `woman` -> `[0.65, 0.91, -0.48, 0.85]`
    

**特点：**

- **稠密向量**：向量维度通常较低（比如300维），且大部分元素都是非零的实数。
    
- 蕴含语义关系：向量之间的关系可以反映概念之间的关系。例如，king和queen的向量会比较接近（因为都是皇室成员），king和man的向量也会比较接近（因为都是男性）。更神奇的是，我们甚至可以进行向量运算来捕捉类比关系，比如著名的：
    
    vector('king') - vector('man') + vector('woman') ≈ vector('queen')
    
- **强大的泛化能力**：由于相似的概念有相似的表示，模型在一个概念上学到的知识可以泛化到相似的概念上。比如模型学到了“国王住在城堡里”，那么它很可能也能推断出“女王也住在城堡里”，因为`king`和`queen`的向量很相似。
    

### 为什么叫“分布式” (Distributed)？

这个名字非常关键，它源于两个层面的“分布”：

1. 一个概念的意义，分布在多个维度上。
    
    不像局部表示那样，king的意义不是由某一个维度决定的。它的“皇室”属性、“男性”属性、“权力”属性等语义特征，被编码并分布在了向量的所有维度上。每个维度都贡献了一小部分语义。你不能说\[0.98, ...]中的0.98就代表“皇室”，它可能与其他维度一起组合起来才表达了这个意思。
    
2. 一个维度，参与表示多个概念。
    
    反过来看，向量的第一个维度（例如\[0.98, 0.95, 0.68, 0.65]）同时参与了对king, queen, man, woman这四个概念的定义。这个维度可能捕捉了一个非常抽象的特征，比如“生物性”或者“人性”，而这四个概念都具备这个特征，只是程度不同。
    

**简单来说，“分布式”意味着概念和其底层的特征之间是一种“多对多”的复杂关系，而不是“一对一”的简单映射。** 信息的表示是“分散”和“共享”的，而不是“集中”和“独立”的。



## Word Type与Word Token
---
**word type** 指的是词汇表中一个**独一无二的词**，而 **word token** 则是文本中出现的**每一个词的实例**。

为了更清晰地说明，我们来看一个简单的例子：

**句子：** "The cat sat on the mat."

在这个句子中：

- **Word Tokens (词元/实例):** 总共有6个词，所以有6个 word tokens。它们分别是 "The", "cat", "sat", "on", "the", "mat"。
    
- **Word Types (词类/类型):** 只有5个独一无二的词，所以有5个 word types。它们分别是 "The", "cat", "sat", "on", "mat"。（"the" 只算一次）
    

### Word Type 与 LLM 的词汇表

LLM拥有一个庞大的“词汇表”，这个词汇表本质上就是模型所知道的所有 **word types** 的集合。然而，LLM的词汇表并非简单地由完整的单词构成。为了高效处理语言的复杂性，现代LLM普遍采用**子词分词 (Subword Tokenization)** 技术，例如字节对编码 (Byte-Pair Encoding, BPE) 或 WordPiece。

这意味着LLM的词汇表（即word types）中不仅包含常见单词，还包含了大量的**子词（subwords）**，如 "##ing", "##ation", "un##" 等。这样做的好处是：

- **有效处理未知词 (Out-of-Vocabulary, OOV)：** 当遇到一个不在词汇表中的新词（例如 "tokenization"）时，模型可以将其拆分为已知的子词（如 "token" 和 "##ization"），从而理解其大致含义，而不是将其视为一个完全未知的单元。
    
- **控制词汇表大小：** 通过共享子词，可以极大地减小词汇表的规模，节省计算资源。
    
- **捕捉构词规律：** 模型能够学习到词根、前缀和后缀的语义信息。
    

因此，在LLM的语境下，**type** 不仅仅是完整的词，更是其词汇表中所有唯一的**token类型**，包括完整词和子词。

###  Word Token 与 LLM 的输入处理

当LLM接收到一段文本输入时，它首先会进行分词，将文本字符串转换成一系列的 **word tokens**。这些tokens随后会被转换成数字ID，并进一步映射为向量（嵌入），成为模型进行计算和预测的实际输入。

一个句子的token数量直接影响着：

- **计算成本：** token数量越多，处理所需的计算资源就越多。
    
- **上下文长度限制 (Context Window)：** 每个LLM都有一个最大的上下文长度限制（例如，4096或128k tokens）。输入的token数量不能超过这个限制。
    

### Word Type 与 Word Token的表示

Word Type, Word Token最终都会表现为向量，但在现代模型中，同一个词的这两个向量通常不相等。
#### 1）它们都是向量吗？

1. **Word Type 的向量**：可以理解为一个词在“词典”中的**基础向量**或**静态向量**。它是模型词汇表（Vocabulary）中存储的那个唯一的、上下文无关的表示。它代表了一个词所有可能含义的综合潜力。
    
2. **Word Token 的向量**：可以理解为一个词在**具体句子中**的**最终向量**或**动态向量**。它是模型在结合了上下文信息之后，为该词在当前语境下的特定含义生成的表示。
    

#### 2）这两个向量完全相等吗？

这取决于你讨论的是哪一类模型。

##### 在静态模型中 (如 Word2Vec, GloVe) - **它们是相等的**
在这些较早的模型中，一个词（Word Type）只有一个固定的词向量。无论这个词出现在什么句子里，它对应的向量（Word Token的向量）都是从词汇表中查到的同一个向量。

- **Word Type "bank"** -> `[0.1, 0.5, -0.2, ...]` (词汇表里存的这一个)
    
- 句子1中的 **Token "bank"**: "I sat on the river **bank**." -> `[0.1, 0.5, -0.2, ...]`
    
- 句子2中的 **Token "bank"**: "I went to the **bank** to deposit money." -> `[0.1, 0.5, -0.2, ...]`
    

**结论**：在这种情况下，**Type向量 和 Token向量 完全相等**。这也是这类模型的主要局限：无法解决一词多义的问题。

#####在动态/上下文相关的模型中 (如 BERT, GPT等LLMs) - **它们不相等**

这正是现代大语言模型的革命性之处。模型在处理一个句子时，会动态地调整每个词的向量。

过程大致如下：

1. **初始查找**：模型首先会为句子中的每个Word Token查找其对应的基础向量（可以看作是Word Type的向量）。
    
2. **上下文融合**：然后，通过注意力机制（Attention Mechanism）等结构，模型会分析这个词的所有邻近词（即上下文）。
    
3. **生成最终向量**：模型将上下文信息融合进初始向量中，生成一个全新的、专门针对当前语境的向量。
    

我们再来看"bank"的例子：

- **Word Type "bank"** -> 有一个初始的基础向量 `[0.1, 0.5, -0.2, ...]`
    
- 句子1: "I sat on the river **bank**."
    
    - 模型看到了 "river"，它会调整 "bank" 的初始向量，使其更偏向“河岸”的含义，生成最终的Token向量 `[0.8, -0.3, 0.6, ...]`。
        
- 句子2: "I went to the **bank** to deposit money."
    
    - 模型看到了 "deposit money"，它会调整 "bank" 的初始向量，使其更偏向“银行”的含义，生成另一个最终的Token向量 `[-0.4, 0.9, -0.1, ...]`。


**结论**：在这种情况下，一个Word Token的最终向量**不等于**其Word Type的初始向量。并且，同一个Word Type的不同Tokens，在不同句子中的向量也**互不相等**。


## Word2Vec: Mathematics
---
用来训练模型的语料库 (Corpus) 通常是**海量的、未经精细筛选的原始文本**，比如Wiki等网站、书籍博客等。
### Objective Function

![图片](/assets/Image/Screenshot 2025-06-27 at 14.26.12.png|500)

在Word2Vec的背景下，参数 `θ` 指的就是模型中所有需要学习的**词向量**。

##### 1. 构建似然函数 L(θ)

似然函数是整个训练语料库中所有预测概率的**连乘**。假设语料库的长度为 `T`，上下文窗口大小为 `m`。

**公式解读**:

- $\prod_{t=1}^{T}$: 遍历语料库中的每一个词（从第1个到第T个）。
    
- $\prod_{-m \le j \le m, j \ne 0}$: 对于每一个中心词 `w_t`，遍历它上下文窗口内的每一个词 `w_{t+j}`。
    
- $P(w_{t+j} | w_t; \theta)$: 计算我们刚刚定义的核心概率。
    
- 整个公式的意义是：将语料库中所有“用中心词预测上下文词”的事件的概率全部乘起来。我们希望这个总概率 `L(θ)` 尽可能大。
    

##### 2. 构建目标/成本函数 J(θ)

**公式解读**:

- $\log P(...)$: 使用对数，**将连乘变成了连加**，大大简化了求导和计算。
    
- $-$ : 加上负号，使得最大化似然 `L(θ)` 变成了最小化成本 `J(θ)`，这与梯度下降等优化算法的目标一致。
    
- $\frac{1}{T}$: 取平均值，使得成本函数的大小与语料库的长度无关，更具一般性。
	

##### 3. 概率P(o|c)的计算

![图片](/assets/Image/Screenshot 2025-06-27 at 14.26.30.png|420)

**公式解读**:

- $u_o^T v_c$: 上下文词的向量 `u_o` 和中心词的向量 `v_c` 进行**点积**。点积结果越大，说明这两个词的向量越相似，它们一起出现的可能性就越高。
    
- $\exp(...)$: 取指数，确保结果为正数。
    
- $\sum_{w \in V} ...$: 分母是**中心词** `v_c` 与词汇表 `V` 中**所有词**的上下文向量 `u_w` 的点积之和。这是一个**归一化**操作，确保所有可能的上下文词的概率加起来等于1。

这个函数其实就是 **softmax**.

![图片](/assets/Image/Screenshot 2025-06-27 at 14.27.08.png|500)


### Center & Context

对于**每一个独立的词 `w`**，模型实际上会学习**两个不同的向量**：

1. **`v_w`**: 当词 `w` 在滑动窗口中扮演 **`Center` (中心词)** 角色时使用的向量。
    
2. **`u_w`**: 当词 `w` 在滑动窗口中扮演 **`Context` (上下文词)** 角色时使用的向量。
    

#### 1）为什么需要两个向量？

使用两套独立的向量（一套 `V` 包含所有中心词向量，一套 `U` 包含所有上下文词向量）有几个好处：

- **增加了模型的参数量**，使其有更强的学习能力。
    
- **简化了求导和优化的过程**。
	想象一下解一个方程 f(x, y) = 0。
		
	a. 两套向量的情况：类似于分别对 x 和 y 求偏导数 ∂f/∂x 和 ∂f/∂y。在求 ∂f/∂x 时，可以把 y 当作常量，反之亦然。这很简单。
		
	b. 一套向量的情况：类似于解一个关于 x 的复杂方程 g(x, x^2, log(x)) = 0。变量 x 以多种不同的形式纠缠在一起，求导过程会复杂得多。
	
- 可以把它看作是模型在学习一个词的两种不同“面相”或“能力”：它作为**发起者（中心）** 的能力和作为**响应者（上下文）** 的能力。
    

#### 2）训练结束后用哪个向量？

将一个词的两个向量加起来（或取平均值）作为这个词最终的、统一的词向量。


## Appendix: Equations
---

### 公式 (1): One-hot 向量表示

$$v_{tea} = \begin{pmatrix} 0 \\ \vdots \\ 1 \\ \vdots \\ 0 \end{pmatrix} \quad v_{coffee} = \begin{pmatrix} 0 \\ \vdots \\ 1 \\ \vdots \\ 0 \end{pmatrix}$$

* **说明**: 这个公式展示了使用 one-hot 向量来表示词语的方法。`tea` 和 `coffee` 被表示为两个独立的标准基向量，其中只有一个维度是1，其余都是0。

### 公式 (2): One-hot 向量的点积

$$v_{tea}^{\top}v_{coffee} = v_{tea}^{\top}v_{the} = 0$$

* **说明**: 此公式表明，任何两个不同词的 one-hot 向量之间的点积都为0。这说明在这种表示法下，所有词语都被认为是同样不相似的。

### 公式 (3): 基于人工标注属性的向量

$$v_{tea} = \begin{pmatrix} \vdots \\ 1 \\ 0 \\ 1 \\ 1 \\ \vdots \end{pmatrix} \begin{matrix} \text{(plural noun)} \\ \text{(3rd singular verb)} \\ \text{(hyponym-of-beverage)} \\ \text{(synonym-of-chai)} \\ \end{matrix}$$

* **说明**: 这个公式举例说明了如何通过人工标注的语言学属性（如是否为复数名词、是否是某个词的下位词等）来构建一个词向量。

### 公式 (4): Skip-gram 模型概率

$$p_{U,V}(o|c) = \frac{\exp u_{o}^{\top}v_{c}}{\sum_{w \in V} \exp u_{w}^{\top}v_{c}}$$

* **说明**: 这是 Word2Vec Skip-gram 模型的核心。它使用 softmax 函数来计算在给定中心词 `c` (其向量为 `vc`) 的情况下，观察到上下文词 `o` (其向量为 `uo`) 的概率。

### 公式 (5): 理论上的目标函数

$$\min_{U,V} \mathbb{E}_{o,c}[-\log p_{U,V}(o|c)]$$

* **说明**: 这是 Word2Vec 学习过程的理论目标。目标是找到参数矩阵 `U` 和 `V`，以最小化在整个数据分布上观测到的负对数似然的期望值（即交叉熵损失）。

### 公式 (6): 经验损失函数

$$L(U,V) = \sum_{d \in D} \sum_{i=1}^{m} \sum_{j=1}^{k} -\log p_{U,V}(w_{i-j}^{(d)}|w_{i}^{(d)})$$

* **说明**: 这个公式是将理论目标（公式5）具体化为在实际数据集 `D` 上的**经验损失**。它对语料库中所有文档、所有中心词及其窗口内的所有上下文词的负对数似然进行求和。

### 公式 (7): 梯度下降更新规则

$$U^{(i+1)} = U^{(i)} - \alpha \nabla_{U}L(U^{(i)}, V^{(i)})$$

* **说明**: 这是参数更新的**梯度下降**规则。它展示了如何通过在损失函数梯度的反方向上移动一小步 `α`，来迭代地更新参数矩阵 `U`。

### 公式 (8): 损失的随机近似

$$\hat{L}(U,V) = \sum_{d_1,...,d_l} \sum_{i=1}^{m} \sum_{j=1}^{k} -\log p_{U,V}(w_{i-j}^{(d)}|w_{i}^{(d)})$$

* **说明**: 这是对完整损失函数 `L(U,V)` 的一个**随机近似**。由于计算完整损失非常昂贵，该公式只在一小批随机采样的文档上计算损失，用于随机梯度下降（SGD）的每一步更新。

### 公式 (9), (10), (11): 梯度计算的分解

$$\nabla_{v_{c}}\hat{L}(U,V) = \sum_{d \in D} \sum_{i=1}^{m} \sum_{j=1}^{k} -\nabla_{v_{c}}\log p_{U,V}(w_{i-j}^{(d)}|w_{i}^{(d)})$$

$$\nabla_{v_{c}}\log p_{U,V}(o|c) = \nabla_{v_{c}}\log\frac{\exp u_{o}^{\top}v_{c}}{\sum_{w \in V} \exp u_{w}^{\top}v_{c}}$$

$$= \underbrace{\nabla_{v_{c}}\log \exp u_{o}^{\top}v_{c}}_{\text{Part A}} - \underbrace{\nabla_{v_{c}}\log \sum_{w=1}^{n}\exp u_{w}^{\top}v_{c}}_{\text{Part B}}$$

* **说明**: 这些公式展示了如何将对损失函数的梯度计算分解为对单个概率项的梯度计算。并利用对数法则，将其进一步分解为 Part A 和 Part B 两部分以便于推导。

### 公式 (12), (13): 梯度计算 Part A

$$\nabla_{v_{c}}\log \exp u_{o}^{\top}v_{c} = \nabla_{v_{c}} u_{o}^{\top}v_{c} = u_o$$

* **说明**: 这部分推导出了梯度计算中 Part A 的结果，即对 `log exp` 项求导，结果就是观测到的上下文词的向量 `uo`。

### 第11页的梯度计算 Part B 及最终结果

$$\nabla_{v_{c}}\log p_{U,V}(o|c) = u_o - \sum_{x=1}^{n}p_{U,V}(x|c)u_x = u_o - \mathbb{E}[u_x]$$

* **说明**: 结合 Part A 和 Part B 的推导结果，得出了关于中心词向量 `vc` 的完整梯度。这个梯度的形式可以被直观地理解为“**观测值减期望值**” ("observed" - "expected")。

### 公式 (14): Softmax 公式（重复展示）

$$p_{U,V}(o|c) = \frac{\exp u_{o}^{\top}v_{c}}{\sum_{w \in V} \exp u_{w}^{\top}v_{c}}$$

* **说明**: 在解释负采样时，笔记再次展示了 Softmax 公式，并标注了分子是“词o与上下文c的亲和度”，分母是“归一化项（或配分函数）”。

### 公式 (15): Skip-gram 负采样 (SGNS) 目标函数

$$\log \sigma(u_{o}^{\top}v_{c}) + \sum_{l=1}^{k} \mathbb{E}_{u_l \sim p_{neg}}[\log \sigma(-u_{l}^{\top}v_{c})]$$

* **说明**: 这是**负采样**方法的目标函数。它将原有的 Softmax 替换为一个更高效的形式：第一项 `log σ(...)` 鼓励观测到的中心词-上下文词对 (`uo`, `vc`) 的向量更相似；第二项 `log σ(-...)` 则鼓励中心词 `vc` 与 `k` 个随机负样本 `ul` 的向量更不相似。
